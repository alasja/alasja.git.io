---
title: "投影"
sidebar: rtr
layout: book
permalink: rtr_ch4_proj.html
summary: 第四章.
---

### 4.6 投影
在你渲染场景之前，场景里所有相关的对象需要投影到某种平面上，或者一个简单的立方体里面。然后裁剪和渲染才能进行（见章节2.3）

我们目前见到的变换都没有使用到第四个分量(w)。这是因为，点和向量在变换后依然是点和向量。4x4矩阵的最底下一行也一直是(0 0 0 1)。`透视投影矩阵`会改变这两个特点：底部的行中包含了点和向量的操作数，所以需要做齐次化操作（也就是，w不是1，所以必须除以w，以得到非齐次的点）。我们会在先介绍`正交投影(Orthographic projection)`，这是一个非常简单的但也使用频繁的投影，它不需要使用w分量。

在这节当中，我们假设观察者朝着z轴负方向观察，y轴是up向量，x轴则是right向量。这是一个右手坐标系。有些软件中，比如DX，使用的是左手坐标系，那么观察者就是看向z轴正方形。两种坐标系都是可以的，最后都会得当相同的效果。

### 4.6.1 正交投影
正交投影的特点是投影后，平行线还是平行线（即线性）。下面的矩阵$P_o$，是一个简单的正交投影矩阵，它保持xy轴不变，设置z为0，也就是垂直的投影到平面 z=0上：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1  \end{pmatrix}  \tag{4.59}
$$

这个投影的效果如图4.16。很显然，该矩阵是不可逆的，因为$\Vert P_o \Vert = 0$。换句话说，这个变化把三维降到了二维形式，目前没有任何办法恢复这个维度损失。使用这种正交矩阵的一个问题是，z值为正值得点和为负的点，都投影到投影平面上了。这在约束z值（xy也可以）到一个特定的范围，从n(近平面）到f(远平面）时会很有用。这也是下一个变形的目的。

![图](/images/RTR3.04.16.png)
图4.16

表示正交投影的一个更常见的方式是`六元组(six-tuple)(l, r, b, t, n, f)`，表示 左， 右， 下， 上， 近， 远六个面。这个矩阵缩放及平移AABB(`Axis-Aligned Bounding Box`;定义见章节16.2)，AABB由前面的六个面构成，中心是原点，与坐标轴平行。AABB最小的拐角是(l,b,n)，最大拐角是(r,t,f)。需要注意的是`n > f`，因为我们看向的是z轴负方向。我们一般的认知会觉得近平面的值应该小于远平面的值。在OpenGL中，也是看向z轴负方向，他提供正交投影矩阵的构造函数`glOrtho`，n的输入值要小于f的输入值，然后在内部把两个值取负。另一种看待OpenGL的n和f的方法是，把他们看成是到观察点的距离，而不是z坐标值。

在OpenGL中，轴对齐立方体的最小点是(-1,-1,-1)，最大点是(1,1,1)；而在DX中，最小点是(-1,-1,0)，最大点是(1,1,1)。这个立方体被称作`标准视体(canonical view volume)`，这个立方体里的坐标则被为`标准化设备坐标(normalized device coordinates)`。图4.17展示了变形处理过程。变换到标准视体的原因是裁剪会更加的统一高效。

![图](/images/RTR3.04.17.png)
图4.17

在变换到标准视体后，图元需要渲染的顶点会被这个立方体裁剪。立方体内的图元最终被映射到屏幕上。OpenGL中的正交变换矩阵如下：
<font size="4">
$$
\begin{align}
P_o = S(s)T(t) &= \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{f-n} & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}  \begin{pmatrix}
1 & 0 & 0 & -\frac{l+r}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{f+n}{2} \\
0 & 0 & 0 & 1
\end{pmatrix} \\
&= \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{l+r}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & \frac{2}{f-n} & -\frac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{pmatrix}. \tag{4.60}
\end{align}
$$
</font>

正如这个等式所示，$P_o$可以写成$T(t)与S(s)$形式，其中$s = (2/(r-l),2/(t-b),2/(f-n)), t = (-(r+l)/2,-(t+b)/2,-(f+n)/2)。这个矩阵是可逆的，即$P_o^{-1} = T(-t)S(1/s) = T(-t)S((r-l)/2,(t-b)/2,(f-n)/2)$。

在计算机图形中，投影之后一般都变成了左手坐标系——就是说，对于`视口(viewport)`，x轴是right向量，y轴是up向量，z轴朝向视口内部。由于我们定义的AABB中，far值是小于near值得，正交变换中总是有一个镜像变换。为了说明这一点，我们先设AABB的大小跟标准视体大小一样。所以AABB的坐标最小点(l,b,n)为(-1,-1,1)，(r,t,f)为(1,1,-1)。则等式4.60变为：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & -1 & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.61}
$$

这是一个镜像矩阵。也就是它把观察的右手坐标系(看下负z轴)变为左手的标准设备坐标系。

DX中z的映射范围为[0,1]，而不是OpenGL中的[-1,1]。这可以使用一个包含缩放和平移的简单矩阵来完成，在正交投影矩阵操作之后使用。这个矩阵如下：

$$
P_o = \begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0.5 & 0.5\\
0 & 0 & 0 & 1
\end{pmatrix}.  \tag{4.62}
$$

所以DX中最终的正交投影矩阵为：

$$
P_{o[0,1]} = \begin{pmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{l+r}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & \frac{1}{f-n} & -\frac{n}{f-n} \\
0 & 0 & 0 & 1
\end{pmatrix}. \tag{4.60}
$$

而且这个矩阵一般要使用它的转置形式，因为DX中矩阵是行优先的形式。


### 4.6.2 投影投影


